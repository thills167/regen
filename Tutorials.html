<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>regen: Tutorials</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="icon-small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">regen
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('Tutorials.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Tutorials </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="tut_win"></a>
Creating a window</h1>
<p>First create the root node of the render tree for your application. The root node will be traversed each frame. </p>
<div class="fragment"><div class="line">ref_ptr&lt;RootNode&gt; rootNode = ref_ptr&lt;RootNode&gt;::manage(<span class="keyword">new</span> RootNode);</div>
</div><!-- fragment --><p>Then instantiate the application and show the window. </p>
<div class="fragment"><div class="line">ref_ptr&lt;QtApplication&gt; app = ref_ptr&lt;QtApplication&gt;::manage(</div>
<div class="line">    <span class="keyword">new</span> QtApplication(rootNode,argc,argv));</div>
<div class="line">app-&gt;set_windowTitle(<span class="stringliteral">&quot;My Application&quot;</span>);</div>
<div class="line">app-&gt;show();</div>
</div><!-- fragment --><p>Finally enter the main loop. This call will block until the engine exits. </p>
<div class="fragment"><div class="line">app-&gt;mainLoop();</div>
</div><!-- fragment --><h1><a class="anchor" id="tut_fbo"></a>
Creating a render target</h1>
<p>Instantiate the FBO. Specify texture dimensions and depth texture parameters. If you set them to anything but GL_NONE the depth texture is automatically attached. </p>
<div class="fragment"><div class="line">FrameBufferObject *fbo = <span class="keyword">new</span> FrameBufferObject(</div>
<div class="line">    width, height, 1,</div>
<div class="line">    GL_TEXTURE_2D,</div>
<div class="line">    GL_DEPTH_COMPONENT24,</div>
<div class="line">    GL_UNSIGNED_BYTE);</div>
<div class="line">ref_ptr&lt;FBOState&gt; fboState = ref_ptr&lt;FBOState&gt;::manage(</div>
<div class="line">    <span class="keyword">new</span> FBOState(ref_ptr&lt;FrameBufferObject&gt;::manage(fbo)));</div>
</div><!-- fragment --><p>Add a color texture to the render target. </p>
<div class="fragment"><div class="line">ref_ptr&lt;Texture&gt; colorAttachment = fbo-&gt;addTexture(1,</div>
<div class="line">    GL_TEXTURE_2D,</div>
<div class="line">    GL_RGBA, GL_RGBA,</div>
<div class="line">    GL_UNSIGNED_BYTE);</div>
</div><!-- fragment --><p>Call glDrawBuffer when the FBOState is traversed. </p>
<div class="fragment"><div class="line">fboState-&gt;addDrawBuffer(GL_COLOR_ATTACHMENT0);</div>
</div><!-- fragment --><p>Clear depth and color attachments when the tree is traversed. </p>
<div class="fragment"><div class="line">ClearColorState::Data clearData;</div>
<div class="line">clearData.clearColor = Vec4f(0.0f);</div>
<div class="line">clearData.colorBuffers.push_back(GL_COLOR_ATTACHMENT0);</div>
<div class="line">fboState-&gt;setClearColor(clearData);</div>
<div class="line">fboState-&gt;setClearDepth();</div>
</div><!-- fragment --><p>Attach the FBO to the render tree. </p>
<div class="fragment"><div class="line">ref_ptr&lt;StateNode&gt; fboNode = ref_ptr&lt;StateNode&gt;::manage(</div>
<div class="line">    <span class="keyword">new</span> StateNode(ref_ptr&lt;State&gt;::cast(fboState)));</div>
<div class="line">rootNode-&gt;addChild(fboNode);</div>
</div><!-- fragment --><p>Display the color attachment by adding a blit state to the render tree. </p>
<div class="fragment"><div class="line">ref_ptr&lt;State&gt; blitState = ref_ptr&lt;State&gt;::manage(</div>
<div class="line">    <span class="keyword">new</span> BlitToScreen(fbo, screenSize, GL_COLOR_ATTACHMENT0));</div>
<div class="line">rootNode-&gt;addChild(ref_ptr&lt;StateNode&gt;::manage(<span class="keyword">new</span> StateNode(blitState)));</div>
</div><!-- fragment --><h1><a class="anchor" id="tut_cube"></a>
Rendering a Cube</h1>
<p>Instantiate the Box mesh, the box is centered at origin. </p>
<div class="fragment"><div class="line">Box::Config cubeConfig;</div>
<div class="line">cubeConfig.posScale = Vec3f(1.0f);</div>
<div class="line">ref_ptr&lt;Mesh&gt; cube = ref_ptr&lt;Mesh&gt;::manage(<span class="keyword">new</span> Box(cubeConfig));</div>
</div><!-- fragment --><p>Move the Box center to another position using the model matrix. </p>
<div class="fragment"><div class="line">ref_ptr&lt;ModelTransformation&gt; modelMat = ref_ptr&lt;ModelTransformation&gt;::manage(<span class="keyword">new</span> ModelTransformation);</div>
<div class="line">modelMat-&gt;translate(Vec3f(-2.0f, 0.75f, 0.0f), 0.0f);</div>
<div class="line">cube-&gt;joinStates(ref_ptr&lt;State&gt;::cast(modelMat));</div>
</div><!-- fragment --><p>Attach a material state to the cube. </p>
<div class="fragment"><div class="line">ref_ptr&lt;Material&gt; material = ref_ptr&lt;Material&gt;::manage(<span class="keyword">new</span> Material);</div>
<div class="line">material-&gt;set_copper();</div>
<div class="line">cube-&gt;joinStates(ref_ptr&lt;State&gt;::cast(material));</div>
</div><!-- fragment --><p>Attach a shader state to the cube. Note that the shader is not yet loaded. </p>
<div class="fragment"><div class="line">ref_ptr&lt;ShaderState&gt; shaderState = ref_ptr&lt;ShaderState&gt;::manage(<span class="keyword">new</span> ShaderState);</div>
<div class="line">cube-&gt;joinStates(ref_ptr&lt;State&gt;::cast(shaderState));</div>
</div><!-- fragment --><p>Add the cube to the render tree. Use the FBO state as parent, so that all rendering is going to the offscreen render target. </p>
<div class="fragment"><div class="line">ref_ptr&lt;StateNode&gt; meshNode = ref_ptr&lt;StateNode&gt;::manage(</div>
<div class="line">    <span class="keyword">new</span> StateNode(ref_ptr&lt;State&gt;::cast(cube)));</div>
<div class="line">fboState-&gt;addChild(meshNode);</div>
</div><!-- fragment --><p>Configure the shader using the hierarchical tree structure. </p>
<div class="fragment"><div class="line">ShaderConfigurer shaderConfigurer;</div>
<div class="line">shaderConfigurer.addNode(meshNode.get());</div>
</div><!-- fragment --><p>Finally compile the shader that is used to render the cube. Note that the 'mesh' shader is used here. It can be considered as some kind of Uber shader that blanks out a lot of unused functionality using the shader configuration generated above. </p>
<div class="fragment"><div class="line">shaderState-&gt;createShader(shaderConfigurer.cfg(), <span class="stringliteral">&quot;mesh&quot;</span>);</div>
</div><!-- fragment --><h1><a class="anchor" id="tut_shading"></a>
Deferred Shading</h1>
<p>Deferred and direct shading is supported but you should use deferred shading whenever possible.</p>
<p>The geometry is processed separated from the shading calculation. The geometry pass renders to G-buffer, the G-buffer must have a set of attachment for the shading to work. In the current implementation attachments for color, specular and for the world space normal are used. Positions are reconstructed from depth values. For the color 2 attachments are used for ping pong rendering. Here is how You can setup the FBO to be a G-buffer. </p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> GLenum count[] = { 2, 1, 1 };</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> GLenum formats[] = { GL_RGBA, GL_RGBA, GL_RGBA };</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> GLenum internalFormats[] = { colorBufferFormat, GL_RGBA, GL_RGBA };</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> GLenum clearBuffers[] = {</div>
<div class="line">    GL_COLOR_ATTACHMENT2, <span class="comment">// spec</span></div>
<div class="line">    GL_COLOR_ATTACHMENT3  <span class="comment">// norWorld</span></div>
<div class="line">};</div>
<div class="line"><span class="keywordflow">for</span>(GLuint i=0; i&lt;<span class="keyword">sizeof</span>(count)/<span class="keyword">sizeof</span>(GLenum); ++i) {</div>
<div class="line">  fbo-&gt;addTexture(count[i], GL_TEXTURE_2D,</div>
<div class="line">      formats[i], internalFormats[i], GL_UNSIGNED_BYTE);</div>
<div class="line">  <span class="comment">// call glDrawBuffer</span></div>
<div class="line">  fboState-&gt;addDrawBuffer(GL_COLOR_ATTACHMENT0+i+1);</div>
<div class="line">}</div>
<div class="line">ref_ptr&lt;Texture&gt; gDiffuseTexture = fbo-&gt;colorBuffer()[0];</div>
<div class="line">ref_ptr&lt;Texture&gt; gSpecularTexture = fbo-&gt;colorBuffer()[2];</div>
<div class="line">ref_ptr&lt;Texture&gt; gNorWorldTexture = fbo-&gt;colorBuffer()[3];</div>
<div class="line">ref_ptr&lt;Texture&gt; gDepthTexture = fbo-&gt;depthTexture();</div>
</div><!-- fragment --><p>Create the shading state and set G-buffer textures. </p>
<div class="fragment"><div class="line">ref_ptr&lt;DeferredShading&gt; shading =</div>
<div class="line">    ref_ptr&lt;DeferredShading&gt;::manage(<span class="keyword">new</span> DeferredShading);</div>
<div class="line">shading-&gt;set_gBuffer(</div>
<div class="line">    gDepthTexture, gNorWorldTexture,</div>
<div class="line">    gDiffuseTexture, gSpecularTexture);</div>
</div><!-- fragment --><p>Setup the render target for the deferred shading pass. </p>
<div class="fragment"><div class="line">ref_ptr&lt;FBOState&gt; fboState =</div>
<div class="line">    ref_ptr&lt;FBOState&gt;::manage(<span class="keyword">new</span> FBOState(gBuffer));</div>
<div class="line"><span class="comment">// Ping-Pong rendering</span></div>
<div class="line">fboState-&gt;setDrawBufferUpdate(gDiffuseTexture, GL_COLOR_ATTACHMENT0);</div>
<div class="line">shading-&gt;joinStatesFront(ref_ptr&lt;State&gt;::manage(<span class="keyword">new</span> FramebufferClear));</div>
<div class="line">shading-&gt;joinStatesFront(ref_ptr&lt;State&gt;::cast(fboState));</div>
</div><!-- fragment --><p>No depth test/write needed during deferred shading. </p>
<div class="fragment"><div class="line">ref_ptr&lt;DepthState&gt; depthState = ref_ptr&lt;DepthState&gt;::manage(<span class="keyword">new</span> DepthState);</div>
<div class="line">depthState-&gt;set_useDepthTest(GL_FALSE);</div>
<div class="line">depthState-&gt;set_useDepthWrite(GL_FALSE);</div>
<div class="line">shading-&gt;joinStatesFront(ref_ptr&lt;State&gt;::cast(depthState));</div>
</div><!-- fragment --><p>Finally add the state to the tree, use the tree to generate a shader configuration and compile shaders used by the deferred shading pipeline. </p>
<div class="fragment"><div class="line">ref_ptr&lt;StateNode&gt; shadingNode = ref_ptr&lt;StateNode&gt;::manage(</div>
<div class="line">    <span class="keyword">new</span> StateNode(ref_ptr&lt;State&gt;::cast(shading)));</div>
<div class="line">rootNode-&gt;addChild(shadingNode);</div>
<div class="line"></div>
<div class="line">ShaderConfigurer shaderConfigurer;</div>
<div class="line">shaderConfigurer.addNode(shadingNode.get());</div>
<div class="line">shading-&gt;createShader(shaderConfigurer.cfg());</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Apr 24 2013 01:05:52 for regen by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.3.1 </li>
  </ul>
</div>
</body>
</html>

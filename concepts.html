<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>regen: Basic concepts</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="regen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="icon-small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">regen
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Basic concepts </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="RenderState"></a>
RenderState</h1>
<p><code>regen</code> uses <a class="el" href="classregen_1_1RenderState.html" title="Handles server-side GL states. ">regen::RenderState</a> to keep track of most GL states and to avoid redundant state changes. Avoiding redundant changes is done using the template class <a class="el" href="classregen_1_1StateStack.html" title="A stack that keeps track of a state value. ">regen::StateStack</a>. The stack compares pushed values with the active value before calling any GL functions. When a value is popped the previous state value is activated.</p>
<p>You should always use the RenderState if it provides a state stack for the particular state of your interest because it keeps track of the value and undefined behavior will occur when the RenderState assumes a wrong state value.</p>
<p>The RenderState is a singleton. You can only use the singleton instance in the rendering thread. Multithreading is not supported. RenderState may manages resources that can not be shared between threads and it does not provide an interface to make the associated context active in the calling thread.</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>regen;</div>
<div class="line"><span class="comment">// Get the singleton and activate the MULTISAMPLE state</span></div>
<div class="line"><span class="comment">// aka. use multiple fragment samples in computing the final color of a pixel.</span></div>
<div class="line"><span class="comment">// Possibly glEnable(GL_MULTISAMPLE) will be called with this push</span></div>
<div class="line"><a class="code" href="classregen_1_1RenderState.html">RenderState</a>()::get()-&gt;toggles().push(<a class="code" href="classregen_1_1RenderState.html">RenderState</a>::MULTISAMPLE, GL_TRUE);</div>
<div class="line">doSomethingWithMultiSampling();</div>
<div class="line"><span class="comment">// Pop value, reset to previous value of MULTISAMPLE state</span></div>
<div class="line"><a class="code" href="classregen_1_1RenderState.html">RenderState</a>()::get()-&gt;toggles().pop();</div>
</div><!-- fragment --><h1><a class="anchor" id="mem"></a>
Memory management</h1>
<p>Dynamic memory allocation is not cheap. GPU memory is precious. Explicit deallocation is error-prone.</p>
<p>For these reasons <code>regen</code> provides some memory management classes.</p>
<h2><a class="anchor" id="ref_ptr"></a>
Reference counting</h2>
<p><code>regen</code> excessively uses the <a class="el" href="classregen_1_1ref__ptr.html" title="Reference counter template class. ">regen::ref_ptr</a> template class for reference counting. The template class supports assignment operator and copy constructor. To access the pointer you can use -&gt; operator. Intern all references share the same counter, if the counter reaches zero <code>delete</code> is called.</p>
<p>You have to explicitly request to manage the memory with reference counting by calling one of the alloc functions.</p>
<p>Simple usage example: </p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>regen;</div>
<div class="line"><span class="keyword">struct </span>Test { <span class="keywordtype">int</span> i; }</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// create reference counted instance of Test data type.</span></div>
<div class="line">  <span class="comment">// the reference count is 1 after calling this.</span></div>
<div class="line">  <a class="code" href="classregen_1_1ref__ptr.html">ref_ptr&lt;Test&gt;</a> i0 = <a class="code" href="classregen_1_1ref__ptr.html#ac26b25152a25a5fcbbf1541a4c4f7467">ref_ptr&lt;Test&gt;::alloc</a>();</div>
<div class="line">  <span class="comment">// assign a new value to the Test instance.</span></div>
<div class="line">  i0-&gt;i = 2;</div>
<div class="line">  <span class="comment">// copy the reference pointer, reference count will be 2 afterwards.</span></div>
<div class="line">  <a class="code" href="classregen_1_1ref__ptr.html">ref_ptr&lt;Test&gt;</a> i1 = i0;</div>
<div class="line">} <span class="comment">// reference count reaches zero when leaving this block</span></div>
</div><!-- fragment --><h2><a class="anchor" id="mem_pool"></a>
Memory pools</h2>
<p><code>regen</code> supports virtual memory allocation using the <a class="el" href="classregen_1_1AllocatorPool.html" title="A pool of memory allocators. ">regen::AllocatorPool</a> template class. An AllocatorPool is defined by an actual allocator and an virtual allocator. Actual allocators are used to actually allocate a block of memory (a GPU memory allocator may calls glGenBuffers and the initial glBufferData). The actual block of pre-allocated memory is managed by the virtual allocator. When someone requests memory from the pool, the pool checks if there is an virtual allocator with enough contiguous space left. If not the pool may actually allocates memory for creating a virtual allocator with enough contiguous free space.</p>
<p>Virtual allocators must implement some interfaces used in the pool template class. The actual unit of the managed memory is arbitrary, it can refer to KBs, MBs, pages or whatever you need to manage. For example if you define your unit as pages you can be sure that no one can allocate blocks smaller then a page-size. Pools allow to align memory to an integer multiplication of the given alignment amount. For example if your unit is bytes and you define an alignment of 16 in the pool, virtual allocators can only allocate blocks of n*16 bytes.</p>
<p>The actual and virtual allocator types are template arguments, you could define your own allocator types and use them together with the memory pool.</p>
<p>Currently only one virtual allocator is implemented: <a class="el" href="classregen_1_1BuddyAllocator.html" title="Implements a variant of the buddy memory allocation algorithm for virtual memory allocation. ">regen::BuddyAllocator</a>, a variant of the buddy memory allocation algorithm. The algorithm uses a binary tree to partition the pre-allocated memory. When memory is allocated the algorithm searches for a <code>free</code> node that offers enough space for the request. When a node was found it is cut into one <code>full</code> node that fits the request exactly and another <code>free</code> node for the remaining space. Allocating some relative small chunks of memory helps in keeping the fragmentation low.</p>
<p>In <code>regen</code> you normally don't use the pools directly. For buffer objects the <a class="el" href="classregen_1_1VBO.html" title="Buffer object that is used for vertex data. ">regen::VBO</a> class provides an interface to use memory pool allocation. Here is an simple example: </p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>regen;</div>
<div class="line"><span class="comment">// Create a new VBO.</span></div>
<div class="line"><span class="comment">// The usage flag determines which pool is used for memory allocation</span></div>
<div class="line"><span class="comment">// and it is a hint for the driver to find a good space in VRAM for the data.</span></div>
<div class="line"><a class="code" href="classregen_1_1ref__ptr.html">ref_ptr&lt;VBO&gt;</a> vbo = <a class="code" href="classregen_1_1ref__ptr.html#ac26b25152a25a5fcbbf1541a4c4f7467">ref_ptr&lt;VBO&gt;::alloc</a>(VBO::USAGE_DYNAMIC);</div>
<div class="line"><span class="comment">// Allocate virtual memory from the pool using the VBO interface.</span></div>
<div class="line"><a class="code" href="classregen_1_1ref__ptr.html">VBOReference</a> ref = vbo-&gt;alloc(NUM_BYTES);</div>
<div class="line"><span class="comment">// Upload data to actual VRAM using the VBOReference.</span></div>
<div class="line"><span class="comment">// The actual upload call `glBufferSubData` is wrapped in a RenderState push and pop</span></div>
<div class="line"><span class="comment">// that makes the referenced buffer the current array buffer.</span></div>
<div class="line"><a class="code" href="classregen_1_1RenderState.html">RenderState</a>()::get()-&gt;arrayBuffer().push(ref-&gt;bufferID());</div>
<div class="line">glBufferSubData(GL_ARRAY_BUFFER, ref-&gt;address(), NUM_BYTES, cpuDataPtr);</div>
<div class="line"><a class="code" href="classregen_1_1RenderState.html">RenderState</a>()::get()-&gt;arrayBuffer().pop();</div>
<div class="line"><span class="comment">// Mark the allocated block as free when you do not use the data on the GPU</span></div>
<div class="line"><span class="comment">// anymore. If you keep the reference for lifetime of VBO then you do not</span></div>
<div class="line"><span class="comment">// need to free the reference manually.</span></div>
<div class="line">vbo-&gt;free(ref);</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>Dynamic memory allocation can be a bottleneck in real-time applications. You should avoid calling new and delete in the render loop. Use pre-allocated memory instead.</dd></dl>
<h1><a class="anchor" id="Animations"></a>
Animations</h1>
<p><a class="el" href="classregen_1_1Animation.html" title="Abstract base class for animations. ">regen::Animation</a>'s can implement two different interfaces: <a class="el" href="classregen_1_1Animation.html#ab94f88dbdbc74ac787fc16762ec82037">regen::Animation::animate</a> and <a class="el" href="classregen_1_1Animation.html#a5d07ab60447d3e20faec1c497108de55">regen::Animation::glAnimate</a>. The first one is executed in an dedicated animation thread without GL context when the function is invoked. The second function will be executed in the render thread with GL context. These interfaces can be used to create simple producer-consumer animations to put some of the computation load on another CPU core.</p>
<p>Animations add themselves to the animation thread when they are constructed. You can remove them again by calling <a class="el" href="classregen_1_1Animation.html#a0de8514303e0146cb61b4b5838f832ed">regen::Animation::stopAnimation</a>. It is ok to call stop in the above interface functions.</p>
<p>The animation thread is synchronized with the render thread. Each animation is invoked once in the animation thread and once in the render thread for each rendered frame.</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>regen;</div>
<div class="line"><span class="keyword">class </span>MyAnimation : <span class="keyword">public</span> <a class="code" href="classregen_1_1Animation.html">Animation</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  MyAnimation()</div>
<div class="line">  : <a class="code" href="classregen_1_1Animation.html">Animation</a>(GL_TRUE,GL_TRUE)</div>
<div class="line">  {}</div>
<div class="line">  <span class="keywordtype">void</span> animate(GLdouble dt)</div>
<div class="line">  {</div>
<div class="line">    doSomethingInAnimThread();</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordtype">void</span> glAnimate(RenderState *rs, GLdouble dt)</div>
<div class="line">  {</div>
<div class="line">    doSomethingInRenderThread();</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="Events"></a>
Events</h1>
<p><a class="el" href="classregen_1_1EventObject.html" title="Allows to integrate events into subclasses. ">regen::EventObject</a> provides a simple interface for providing sync and async event messages to other components via callback functions. For async events the connected callbacks are called after the next frame was rendered within the render thread (with GL context). For example this event mechanism is used to dispatch GUI events from the GUI thread to the render thread.</p>
<p>Implementing <a class="el" href="classregen_1_1EventObject.html" title="Allows to integrate events into subclasses. ">regen::EventObject</a> is easy. Each <a class="el" href="classregen_1_1EventObject.html" title="Allows to integrate events into subclasses. ">regen::EventObject</a> can define multiple named events by calling the static function <a class="el" href="classregen_1_1EventObject.html#a960c9f22b9bf76cfa7d408190991c799">regen::EventObject::registerEvent</a>. This has to be done only once per class (not once per instance). The function returns an unique event id that can be use to refer to the registered event.</p>
<p>After the event was registered <a class="el" href="classregen_1_1EventObject.html" title="Allows to integrate events into subclasses. ">regen::EventObject</a> implementations can call <a class="el" href="classregen_1_1EventObject.html#a8649fc8f5e945b4482c6fa3bcbd84e42">regen::EventObject::emitEvent</a> for an synch event or <a class="el" href="classregen_1_1EventObject.html#a461b2d08a7a3ddffea3a3288d17fbdab">regen::EventObject::queueEmit</a> for an asynch event. If you need any special event data you can subclass <a class="el" href="classregen_1_1EventData.html" title="Data passed from event emitter to event handlers. ">regen::EventData</a> and pass it to the emit function.</p>
<p>Listeners can be connected to and disconnted from <a class="el" href="classregen_1_1EventObject.html" title="Allows to integrate events into subclasses. ">regen::EventObject</a>'s. Event listeners must subclass <a class="el" href="classregen_1_1EventHandler.html" title="Baseclass for event handler. ">regen::EventHandler</a> and implement <a class="el" href="classregen_1_1EventHandler.html#a596806401e6999c6c698e6415de55750">regen::EventHandler::call</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>regen;</div>
<div class="line"></div>
<div class="line"><span class="comment">// EventObject&#39;s provide events listeners can connect to.</span></div>
<div class="line"><span class="keyword">class </span>MyEventObject : <span class="keyword">public</span> <a class="code" href="classregen_1_1EventObject.html">EventObject</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="comment">// This is the event identifier. We have to call EventObject::registerEvent</span></div>
<div class="line">  <span class="comment">// to set the value.</span></div>
<div class="line">  <span class="keyword">static</span> GLuint MY_EVENT;</div>
<div class="line">  <span class="comment">// Each time MY_EVENT is emitted a MyEvent instance is generated</span></div>
<div class="line">  <span class="comment">// and passed to connected handlers.</span></div>
<div class="line">  <span class="keyword">class </span>MyEvent : <span class="keyword">public</span> <a class="code" href="classregen_1_1EventData.html">EventData</a></div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// add relevant data here...</span></div>
<div class="line">    <span class="keywordtype">void</span> *myEventData;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line">  MyEventObject() : <a class="code" href="classregen_1_1EventObject.html">EventObject</a>() {}</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Instantiate MyEvent and invoke connected listener.</span></div>
<div class="line">  <span class="keywordtype">void</span> emitMyEvent(<span class="keywordtype">void</span> *myEventData)</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="classregen_1_1ref__ptr.html">ref_ptr&lt;MyEvent&gt;</a> <span class="keyword">event</span> = <a class="code" href="classregen_1_1ref__ptr.html#ac26b25152a25a5fcbbf1541a4c4f7467">ref_ptr&lt;MyEvent&gt;::alloc</a>();</div>
<div class="line">    <span class="keyword">event</span>-&gt;myEventData = myEventData;</div>
<div class="line">    <span class="comment">// synchronous message</span></div>
<div class="line">    emitEvent(MY_EVENT, event);</div>
<div class="line">    <span class="comment">// asynchronous message</span></div>
<div class="line">    <span class="comment">// queueEmit(MY_EVENT, event);</span></div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"><span class="comment">// statically register the event</span></div>
<div class="line">GLuint MyEventObject::MY_EVENT = <a class="code" href="classregen_1_1EventObject.html#a960c9f22b9bf76cfa7d408190991c799">EventObject::registerEvent</a>(<span class="stringliteral">&quot;my-event&quot;</span>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// EventHandler is the interface used to connect to events.</span></div>
<div class="line"><span class="keyword">class </span>MyEventHandler : <span class="keyword">public</span> <a class="code" href="classregen_1_1EventHandler.html">EventHandler</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  MyEventHandler(e) : <a class="code" href="classregen_1_1EventHandler.html">EventHandler</a>() {}</div>
<div class="line"></div>
<div class="line">  <span class="comment">// EventHandler subclasses must implement this method.</span></div>
<div class="line">  <span class="keywordtype">void</span> call(<a class="code" href="classregen_1_1EventObject.html">EventObject</a> *evObject, <a class="code" href="classregen_1_1EventData.html">EventData</a> *evData)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// If you connect to a single event only, this check is not needed.</span></div>
<div class="line">    <span class="keywordflow">if</span>(evData-&gt;<a class="code" href="classregen_1_1EventData.html#a9be8676ba025896cff7f548443b08f0e">eventID</a> == MyEventObject::MY_EVENT)</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// you probably should use dynamic_cast&lt;&gt; and check for NULL pointer</span></div>
<div class="line">      <span class="comment">// but if you don&#39;t care and know that the type is right just use unsafe casts</span></div>
<div class="line">      MyEventObject *obj = (MyEventObject*)evObject;</div>
<div class="line">      MyEvent *ev = (MyEvent*)evData;</div>
<div class="line">      handleEvent(obj,ev);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// instantiate and connect handler</span></div>
<div class="line">MyEventObject evObj;</div>
<div class="line">evObj.connect(MyEventObject::MY_EVENT, <a class="code" href="classregen_1_1ref__ptr.html">ref_ptr&lt;MyEventHandler&gt;::alloc</a>());</div>
<div class="line">evObj.emitMyEvent(NULL);</div>
</div><!-- fragment --><h1><a class="anchor" id="Shader"></a>
Shader Loading</h1>
<p>When a shader is loaded the code is pre-processed on the CPU before it is send to the GL. Regular GLSL code should work fine but the actual code send to the GL maybe different from the code passed in.</p>
<h2><a class="anchor" id="directives"></a>
Directive handling</h2>
<ul>
<li>#define can be used as usual</li>
<li>#ifdef,#if,#elif,#else,#endif directives are evaluated and undefined code is not send to the GL.</li>
<li>#line directives are ignored and not send to the GL as they are confusing in combination with the pre-processors.</li>
<li>#version directives are not send to GL as passed in. The directive processor look for the maximum version and at last the #version directive with maximum version is prepended to shader code (ATI is really strict about having the version directive the very first statement in the code).</li>
</ul>
<h2><a class="anchor" id="macro_replace"></a>
Macro name replacing</h2>
<p>Macro names are only replaced by the defined value when explicitly requested using a special notation. The notation is a leading dollar sign followed by the macro name surrounded by curly brackets. For example: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#define FOO 2</span></div>
<div class="line"><span class="preprocessor">int i = ${FOO};</span></div>
</div><!-- fragment --><h2><a class="anchor" id="include_directive"></a>
#include directive</h2>
<p>#include directives are supported using GLSW. They are evaluated recursively. You can add custom include paths with <a class="el" href="classregen_1_1Application.html#af478e5032c804b29c708d9ea94037518">regen::Application::addShaderPath</a>. The include key is build from the shader filename and a named section in the shader. Nodes in the path are separated by dots. For example to load the subsection 'bar' from the section 'foo' in the file 'baz' the include key would be 'baz.foo.bar'. The actual GLSL code would look like this: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include baz.foo.bar</span></div>
</div><!-- fragment --><p><a class="el" href="classregen_1_1ShaderState.html" title="Binds Shader program to the RenderState. ">regen::ShaderState</a> scans for implemented shader stages by appending the shader stage prefix (regen::glenum::glslStagePrefix) to the include key and compiles all defined stages into the shader program.</p>
<h2><a class="anchor" id="define2_directive"></a>
#define2 directive</h2>
<p>Practically the same as #define with the exception that the define is not included in the code send to GL. In other words this define can only be used by CPU pre-processors. For example this would work as intended: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#define2 HAS_FOO</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#ifdef HAS_FOO</span></div>
<div class="line"><span class="preprocessor"></span>do_something();</div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><h2><a class="anchor" id="for_directive"></a>
#for directive</h2>
<p>A #for directive is supported that allows to define code n-times. Inside the for loop the current index in the for loop can be accessed. The index is actually defined using the #define2 directive. For example following would be repeated 8 times: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#for INDEX to 8</span></div>
<div class="line"><span class="preprocessor"></span>  {</div>
<div class="line">    <span class="keywordtype">int</span> i = ${INDEX};</div>
<div class="line">  }</div>
<div class="line"><span class="preprocessor">#endfor</span></div>
</div><!-- fragment --><h2><a class="anchor" id="io_names"></a>
IO name matching</h2>
<p>The pre-processor handles name matching between shader stages by redefining the IO names. It is good practice to use 'in_' and 'out_' prefix for all inputs and outputs in each shader stage and let the pre-processor decide about the naming. You could also bypass this suggestion and give the IO data arbitrary names.</p>
<p>For attributes a stage prefix (regen::glenum::glslStagePrefix) is prepended, uniforms get a 'u_' prefix and constants get a 'c_' prefix.</p>
<p>For example this code is valid: </p>
<div class="fragment"><div class="line">-- vs</div>
<div class="line">in vec3 in_pos;</div>
<div class="line">out vec3 out_pos;</div>
<div class="line"><span class="keywordtype">void</span> main() {</div>
<div class="line">  out_pos = in_pos;</div>
<div class="line">}</div>
<div class="line">-- fs</div>
<div class="line">in vec3 in_pos;</div>
<div class="line"><span class="keywordtype">void</span> main() {</div>
<div class="line">  do_something(in_pos);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="io_gen"></a>
IO generator</h2>
<p>Often you don't do anything special with attributes in a shader stage and only pass them through to the stage that actually operates on the data. The pre-processor can generate such pass through code for you. This actually allows defining shader stages without knowing the input attributes of the following stage allowing to define more generic shaders.</p>
<p>When a stage is processed the pre-processor iterates over the inputs declared in the following state and makes sure that there is matching input. If not a pass through output is generated.</p>
<p>The generator does only operate when you explicitly request it. The IO code is generated only if you define HANDLE_IO(i) somewhere outside the main function. Additionally you have to call this macro somewhere inside the main function.</p>
<p>For example this code would pass an attribute named 'foo' to the fragment shader: </p>
<div class="fragment"><div class="line">-- vs</div>
<div class="line"><span class="preprocessor">#define HANDLE_IO(i)</span></div>
<div class="line"><span class="preprocessor"></span><span class="keywordtype">void</span> main() {</div>
<div class="line">  HANDLE_IO(glVertexID);</div>
<div class="line">}</div>
<div class="line">-- fs</div>
<div class="line">in vec3 in_foo;</div>
<div class="line"><span class="keywordtype">void</span> main() {</div>
<div class="line">  do_something(in_foo);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="io_trans"></a>
IO transformation</h2>
<p>Shader input in this engine is defined as constant input (never changing for a compiled program), uniform input (not changing during shader invocation), vertex attribute input (changing per vertex) and instanced attribute input (changing per instance). On the CPU all types of input are represented by <a class="el" href="classregen_1_1ShaderInput.html" title="Provides input to shader programs. ">regen::ShaderInput</a>.</p>
<p>Pre-processors allow transformation from one input type to another. This allows defining code without knowing the actual type of the input. For example you can define a simple material shader declaring all material inputs as constant inputs and this shader could also be used as instanced material shader or none constant material shader using uniforms.</p>
<h1><a class="anchor" id="Logging"></a>
Logging</h1>
<p>Use <a class="el" href="classregen_1_1Logging.html#af712a27665d5980c6323452f39f3d23a">regen::Logging::addLogger</a> to define a logger for a given level. For example if you would like to see INFO messages on console: </p>
<div class="fragment"><div class="line"><a class="code" href="classregen_1_1Logging.html#af712a27665d5980c6323452f39f3d23a">regen::Logging::addLogger</a>(<span class="keyword">new</span> <a class="code" href="classregen_1_1CoutLogger.html">regen::CoutLogger</a>(regen::Logging::INFO));</div>
</div><!-- fragment --><p>Use log macros with &lt;&lt; operator to log a message: </p>
<div class="fragment"><div class="line">REGEN_INFO(<span class="stringliteral">&quot;value=&quot;</span>&lt;&lt;value);</div>
</div><!-- fragment --><p>Use <a class="el" href="classregen_1_1Application.html#acf72b2b646adcc90ab35807919c2c2de">regen::Application::setupLogging</a> if you want to see all log messages on the console. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Nov 7 2013 11:57:34 for regen by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>

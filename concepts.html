<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>regen: Basic concepts</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="icon-small.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">regen
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('concepts.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Basic concepts </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="Logging"></a>
Logging</h1>
<p>Use <a class="el" href="classregen_1_1Logging.html#af712a27665d5980c6323452f39f3d23a">regen::Logging::addLogger</a> to define a logger for a given level. For example if you would like to see INFO messages on console: </p>
<div class="fragment"><div class="line">Logging::addLogger(<span class="keyword">new</span> CoutLogger(Logging::INFO));</div>
</div><!-- fragment --><p>Use log macros with &lt;&lt; operator to log a message: </p>
<div class="fragment"><div class="line">INFO_LOG(<span class="stringliteral">&quot;value=&quot;</span>&lt;&lt;value);</div>
</div><!-- fragment --><h1><a class="anchor" id="cpu_mem"></a>
CPU-side Memory management</h1>
<p>regen excessively uses the <a class="el" href="classregen_1_1ref__ptr.html" title="Adds auto reference Management to a pointer.">regen::ref_ptr</a> template class for memory management. The template class supports assignment operator and copy constructor. To access the pointer you can use -&gt; operator. Intern all references share the same counter, if the counter reaches zero delete is called.</p>
<p>You have to explicitly request to manage the memory with reference counting using <a class="el" href="classregen_1_1ref__ptr.html#adce623adb3524c797afb084dee011de4">regen::ref_ptr::manage</a>. Make sure to manage data only once or you will run into double free corruption.</p>
<p>Simple usage example: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Test { <span class="keywordtype">int</span> i; }</div>
<div class="line">ref_ptr&lt;Test&gt; i0 = ref_ptr&lt;Test&gt;::manage(<span class="keyword">new</span> Test);</div>
<div class="line">i0-&gt;i = 2;</div>
<div class="line">ref_ptr&lt;Test&gt; i1 = i0;</div>
</div><!-- fragment --><p>Dynamic memory allocation can be a bottleneck in real-time applications. You should avoid calling new and delete in the render loop. Use pre-allocated RAM instead.</p>
<h1><a class="anchor" id="gpu_mem"></a>
GPU-side Memory management</h1>
<p>regen uses <a class="el" href="classregen_1_1VBOManager.html" title="Helps using VertexBufferObject&#39;s.">regen::VBOManager</a> to keep track of allocated VRAM. The VRAM is allocated in blocks of a few MB and organized in a free list of contiguous GPU memory blocks.</p>
<h1><a class="anchor" id="Animations"></a>
Animations</h1>
<p>Animation's in regen can implement two different interfaces: <a class="el" href="classregen_1_1Animation.html#ab94f88dbdbc74ac787fc16762ec82037">regen::Animation::animate</a> and <a class="el" href="classregen_1_1Animation.html#a5d07ab60447d3e20faec1c497108de55">regen::Animation::glAnimate</a>. The first one is executed in an dedicated animation thread without GL context setup when the function is invoked. The second function will be executed in the render thread with GL context setup. These interfaces can be used to create simple producer-consumer animations to put some of the computation load on another CPU core.</p>
<p>Animations add themselves to the animation thread when they are constructed. You can remove them again calling <a class="el" href="classregen_1_1Animation.html#a0de8514303e0146cb61b4b5838f832ed">regen::Animation::stopAnimation</a>. It is ok to call stop in the above interface functions.</p>
<p>The animation thread is synchronized with the render thread. Each animation is invoked once in the animation thread and once in the render thread for each rendered frame.</p>
<h1><a class="anchor" id="Events"></a>
Events</h1>
<p><a class="el" href="classregen_1_1EventObject.html" title="Allows to integrate events into subclasses.">regen::EventObject</a> implements a simple interface for providing sync and async event messages to other components. Event providers must call <a class="el" href="classregen_1_1EventObject.html#a960c9f22b9bf76cfa7d408190991c799">regen::EventObject::registerEvent</a> with an unique event name. Other components can connect callbacks to the event. The event provider decides if the message is send directly to listeners &ndash; using <a class="el" href="classregen_1_1EventObject.html#ad7262b8beaaf6d5af87dec99d3a373f2">regen::EventObject::emitEvent</a> within the same thread the event message was generated &ndash; or if the message is send async via <a class="el" href="classregen_1_1EventObject.html#aa2ec1cc5026f3894e428750a702e63f2">regen::EventObject::queueEmit</a> to be processed in the rendering thread.</p>
<h1><a class="anchor" id="Shader"></a>
Shader Loading</h1>
<p>When a shader is loaded the code is pre-processed on the CPU before it is send to the GL. Regular GLSL code should work fine but the actual code send to the GL maybe different from the code passed in.</p>
<p>The pre-processors are implemented in <a class="el" href="classregen_1_1GLSLInputOutputProcessor.html" title="A GLSL processor that modifies the IO behavior of the Shader code.">regen::GLSLInputOutputProcessor</a> and <a class="el" href="classregen_1_1GLSLDirectiveProcessor.html" title="Offline Processing of Shader PreProcessor directives.">regen::GLSLDirectiveProcessor</a>.</p>
<h2><a class="anchor" id="directives"></a>
Directive handling</h2>
<ul>
<li>#define can be used as usual</li>
<li>#ifdef,#if,#elif,#else,#endif directives are evaluated and undefined code is not send to the GL.</li>
<li>#line directives are ignored and not send to the GL as they are confusing in combination with the pre-processors.</li>
<li>#version directives are not send to GL as passed in. The directive processor look for the maximum version and at last the #version directive with maximum version is prepended to shader code (ATI is really strict about having the version directive the very first statement in the code).</li>
</ul>
<h2><a class="anchor" id="macro_replace"></a>
Macro name replacing</h2>
<p>Macro names are only replaced by the defined value when explicitly requested using a special notation. The notation is a leading dollar sign followed by the macro name surrounded by curly brackets. For example: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#define FOO 2</span></div>
<div class="line"><span class="preprocessor">int i = ${FOO};</span></div>
</div><!-- fragment --><h2><a class="anchor" id="include_directive"></a>
#include directive</h2>
<p>#include directives are supported using GLSW. They are evaluated recursively. You can add custom include paths with ogle::Application::addShaderPath. The include key is build from the shader filename and a named section in the shader. Nodes in the path are separated by dots. For example to load the subsection 'bar' from the section 'foo' in the file 'baz' the include key would be 'baz.foo.bar'. The actual GLSL code would look like this: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include baz.foo.bar</span></div>
</div><!-- fragment --><p><a class="el" href="classregen_1_1ShaderState.html" title="Binds Shader program to the RenderState.">regen::ShaderState</a> scans for implemented shader stages by appending the shader stage prefix (<a class="el" href="classregen_1_1GLEnum.html#a76190326ae7434fd7df520ffb0614fb0">regen::GLEnum::glslStagePrefix</a>) to the include key and compiles all defined stages into the shader program.</p>
<h2><a class="anchor" id="define2_directive"></a>
#define2 directive</h2>
<p>Practically the same as #define with the exception that the define is not included in the code send to GL. In other words this define can only be used by CPU pre-processors. For example this would work as intended: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#define2 HAS_FOO</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#ifdef HAS_FOO</span></div>
<div class="line"><span class="preprocessor"></span>do_something();</div>
<div class="line"><span class="preprocessor">#endif</span></div>
</div><!-- fragment --><h2><a class="anchor" id="for_directive"></a>
#for directive</h2>
<p>A #for directive is supported that allows to define code n-times. Inside the for loop the current index in the for loop can be accessed. The index is actually defined using the #define2 directive. For example following would be repeated 8 times: </p>
<div class="fragment"><div class="line"><span class="preprocessor">#for INDEX to 8</span></div>
<div class="line"><span class="preprocessor"></span>  {</div>
<div class="line">    <span class="keywordtype">int</span> i = ${INDEX};</div>
<div class="line">  }</div>
<div class="line"><span class="preprocessor">#endfor</span></div>
</div><!-- fragment --><h2><a class="anchor" id="io_names"></a>
IO name matching</h2>
<p>The pre-processor handles name matching between shader stages by redefining the IO names. It is good practice to use 'in_' and 'out_' prefix for all inputs and outputs in each shader stage and let the pre-processor decide about the naming. You could also bypass this suggestion and give the IO data arbitrary names.</p>
<p>For attributes a stage prefix (<a class="el" href="classregen_1_1GLEnum.html#a76190326ae7434fd7df520ffb0614fb0">regen::GLEnum::glslStagePrefix</a>) is prepended, uniforms get a 'u_' prefix and constants get a 'c_' prefix.</p>
<p>For example this code is valid: </p>
<div class="fragment"><div class="line">-- vs</div>
<div class="line">in vec3 in_pos;</div>
<div class="line">out vec3 out_pos;</div>
<div class="line"><span class="keywordtype">void</span> main() {</div>
<div class="line">  out_pos = in_pos;</div>
<div class="line">}</div>
<div class="line">-- fs</div>
<div class="line">in vec3 in_pos;</div>
<div class="line"><span class="keywordtype">void</span> main() {</div>
<div class="line">  do_something(in_pos);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="io_gen"></a>
IO generator</h2>
<p>Often you don't do anything special with attributes in a shader stage and only pass them through to the stage that actually operates on the data. The pre-processor can generate such pass through code for you. This actually allows defining shader stages without knowing the input attributes of the following stage allowing to define more generic shaders.</p>
<p>When a stage is processed the pre-processor iterates over the inputs declared in the following state and makes sure that there is matching input. If not a pass through output is generated.</p>
<p>The generator does only operate when you explicitly request it. The IO code is generated only if you define HANDLE_IO(i) somewhere outside the main function. Additionally you have to call this macro somewhere inside the main function.</p>
<p>For example this code would pass an attribute named 'foo' to the fragment shader: </p>
<div class="fragment"><div class="line">-- vs</div>
<div class="line"><span class="preprocessor">#define HANDLE_IO(i)</span></div>
<div class="line"><span class="preprocessor"></span><span class="keywordtype">void</span> main() {</div>
<div class="line">  HANDLE_IO(glVertexID);</div>
<div class="line">}</div>
<div class="line">-- fs</div>
<div class="line">in vec3 in_foo;</div>
<div class="line"><span class="keywordtype">void</span> main() {</div>
<div class="line">  do_something(in_foo);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="io_trans"></a>
IO transformation</h2>
<p>Shader input in this engine is defined as constant input (never changing for a compiled program), uniform input (not changing during shader invocation), vertex attribute input (changing per vertex) and instanced attribute input (changing per instance). On the CPU all types of input are represented by <a class="el" href="classregen_1_1ShaderInput.html" title="Provides input to shader programs.">regen::ShaderInput</a>.</p>
<p>Pre-processors allow transformation from one input type to another. This allows defining code without knowing the actual type of the input. For example you can define a simple material shader declaring all material inputs as constant inputs and this shader could also be used as instanced material shader or none constant material shader using uniforms. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Apr 24 2013 01:39:15 for regen by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.3.1 </li>
  </ul>
</div>
</body>
</html>
